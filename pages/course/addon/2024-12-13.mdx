# 12.13 上机课

import { Callout } from 'nextra/components'

<Callout type='info'>
编程题目的答案不是唯一的，能够通过评测即为正确。本次测试最后两题的难度较高，仅供探索学习。

题目均选自头歌实践平台的“编程刷题”模块，可以自行搜索题目，测试自己的代码

![wjsoj/wgPlCYpx.png](https://img-api.pku3d.com/ota/wjsoj/wgPlCYpx.png)
</Callout>

## 单选题

1. 在Python中，如何创建一个空的字典？

    A．set()
    B．dictionary()
    C．map()
    D．`{}`

    **答案： D**

2. 以下哪个选项不是Python中集合的特点？
    
    A．无序
    B．可变
    C．允许重复元素
    D．不可哈希

    **答案： C**

> D选项：python内置了`hash()`函数，可以自行测试验证，集合是不可哈希的。可变数据类型`list`、`set`、`dict`都是不可哈希的。

3. 在Python中，if语句后面跟什么来表示条件？
    
    A．`==`
    B．`=`
    C．`!`
    D．`:`

    **答案： A**

4. 在Python中，用于遍历序列的循环语句是？
    
    A．for
    B．while
    C．do...while
    D．foreach

    **答案： A**

5. 哪一年被广泛认为是人工智能元年？
    
    A．1950
    B．1956
    C．1960
    D．1965

    **答案： B**

> 1956年，达特茅斯会议首次提出了'人工智能'这一术语，这一年被认为是人工智能的元年。

6. 以下哪个领域不是人工智能的主要应用？
    
    A．自动驾驶
    B．医疗诊断
    C．天气预报
    D．艺术创作

    **答案： D**

7. Python字典中用于获取键值对的方法是？
    
    A．keys()
    B．values()
    C．items()
    D．get()

    **答案： C**

> `items()`方法常用于同时遍历键值对，例如`for key, value in my_dict.items()`

8. 在Python中，如何检查一个元素是否存在于集合中？
    
    A．`==`
    B．`in`
    C．`exist()`
    D．`has()`

    **答案： B**

9. 在Python中，用于跳出当前循环的关键字是？

    A．continue
    B．break
    C．return
    D．exit

    **答案： B**

10. 以下哪种技术不属于人工智能的应用？

    A．机器学习
    B．深度学习
    C．区块链
    D．自然语言处理

    **答案： C**

## 编程题

### 最大的能被整除的数

import { Tabs } from 'nextra/components'

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
输入一个大于 `0` 的整数 `n`，求 `10000` 之内的最大的能被 `n` 整除的整数，输出这个整数。

#### 输入格式
一个整数。

#### 输出格式
一个整数。

#### 输入输出样例
##### 输入
`13`

##### 输出
`9997`

##### 样例说明
`13 % 13 = 0`，`13 < 10000`，
`26 % 13 = 0` ，`26 < 10000`，
`39 % 13 = 0` ，`39 < 10000`，
`······`，
`9997 % 13 = 0`，`9997 < 10000`，
`10010 % 13  = 0` ，`10010 > 10000`，
即小于等于 `10000` 的能被 `13` 整除的最大的整数为 `9997`。

    </Tabs.Tab>
    <Tabs.Tab>
        签到题

        答案1：
        ```python copy
        n = int(input())
        print(10000//n * n)
        ```

        答案2：
        ```python copy
        n = int(input())
        print(10000 - 10000 % n)
        ```
    </Tabs.Tab>
</Tabs>

### 打酱油

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>
#### 题目描述
小明带着 `N` 元钱去买酱油。酱油 `10` 块钱一瓶，商家进行促销，每买 `3` 瓶送 `1` 瓶，或者每买 `5` 瓶送 `2` 瓶。请问小明最多可以得到多少瓶酱油。

#### 输入输出格式
**输入格式**
输入的第一行包含一个整数 `N`，表示小明可用于买酱油的钱数。`N` 是 `10` 的整数倍，`N` 不超过 `300`。

**输出格式**
输出一个整数，表示小明最多可以得到多少瓶酱油。

#### 输入输出样例1
**输入**

`40`

**输出**

`5`

**解释**

把 `40` 元分成 `30` 元和 `10` 元，分别买 `3` 瓶和 `1` 瓶，其中 `3` 瓶送 `1` 瓶，共得到 `5` 瓶。

#### 输入输出样例2
**输入**

`80`

**输出**

`11`

**解释**

把 `80` 元分成 `30` 元和 `50` 元，分别买 `3` 瓶和 `5` 瓶，其中 `3` 瓶送 `1` 瓶，`5` 瓶送 `2` 瓶，共得到 `11` 瓶。

    </Tabs.Tab>
    <Tabs.Tab>
        简单的贪心，明显优先买 `5` 瓶送 `2` 瓶更优惠，钱不够时先买 `3` 瓶送 `1` 瓶，最后剩下的钱买 `10` 块钱一瓶的酱油。

        答案：
        ```python copy
        n = int(input())
        print((n//50) * 7 + ((n%50)//30) * 4 + (n%50%30)//10)
        ```
    </Tabs.Tab>
</Tabs>

### 找规律

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
题目中会给你一个整数数组 `num`，`num=[1,2,2,3,3,3.....]`，然后题目中会给你一个整数 `k`，现在请你找出 `num` 的规律，并编写代码计算数组的前 `k` 项和为多少？

#### 输入输出格式

**输入格式**
一个整数`k`。

**输出格式**
一个整数。
#### 输入输出样例1

**输入**

`5`

**输出**

`11`

#### 输入输出样例2

**输入**

`10`

**输出**

`30`

    </Tabs.Tab>
    <Tabs.Tab>
        想办法构造出这个数组，然后求和即可。或者用循环，对于第`i`个数，加`i`次，相当于求出`i*i`，最后再把剩下的数加上。

        答案：

        ```python copy
        n = int(input())
        ans = 0
        now = 1
        while n >= now:
            n -= now
            ans += now**2
            now += 1
        print(ans + n*now)
        ```

        一行流：

        这里用到了二重循环的列表推导式，第一重表示当前的数`i`，第二重表示重复`i`次，实际上第一重循环后的`n+1`并不需要取这么大，只要能保证最终构造出的列表长度大于`n`即可

        ```python copy
        n = int(input())
        print(sum([i for i in range(1, n+1) for _ in range(i)][:n]))
        ```
    </Tabs.Tab>
</Tabs>

### 位置的数量

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
彼得站在 `n`个人的队伍中，但他不知道自己究竟占据了哪个位置。 他只能知道，站在他面前的人不少于`a`人，站在他身后的人不超过`b`人。 请找出 Petr 可以占据的不同位置的数量。


#### 输入格式
** 在同一行的数据均用空格分隔。 **  
唯一一行包含三个整数 $n$、$a$和 $b (0 \le a, b ,n \le 100)$。

#### 输出格式
打印单个数字 。


#### 输入输出样例

##### 输入
`3 1 1`


##### 输出
`2`

    </Tabs.Tab>
    <Tabs.Tab>
        找规律的题目。

        对于`a+b < n`的情况，位置不会受到前面`a`这个条件的限制，所以答案就是`b+1`（站在身后的可以是`0~b`人，所以共`b+1`种可能）。

        对于有重叠的情况，容易求出重叠占掉的位置`(a+b-n+1)`（当`a+b=n`的时候，前面`a`人，后面`b`人这种位置已经被占掉了，所以最后+1），那么答案就是`b+1`减去占掉的位置，即$(b+1)-(a+b-n+1) = n-a$。

        答案：
        ```python copy
        n,a,b = map(int, input().split())
        print(n-a if a+b >= n else b+1)
        ```
    </Tabs.Tab>
</Tabs>

### 钱币找零

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
假设 1 元、  5 元、 10 元、 20 元、 50 元、 100 元的纸币，张数不限制，现在要用来支付 K 元，至少要多少张纸币？

#### 输入格式
输入数据为一个整数

#### 输出格式
输出数据为字符串，例："需要 x 张 xx 块的"。

#### 输入输出样例

**输入1**
```
59
```
**输出1**
```
需要1张50块的
需要1张5块的
需要4张1块的
```
**输入2**
```
154
```
**输出2**
```
需要1张100块的
需要1张50块的
需要4张1块的
```

    </Tabs.Tab>
    <Tabs.Tab>
        简单贪心，参见课程PPT，每次尽量用大面额的纸币。这里提供了一种简便的写法，实际上贪心思想暗含在`moneys`列表的设置中，默认就是从大到小遍历。

        答案：

        ```python copy
        n = int(input())
        moneys = [100, 50, 20, 10, 5, 1]
        for money in moneys:
            if n // money:
                print(f"需要{n // money}张{money}块的")
            n %= money
        ```
        
        值得注意的是，找零问题并不一定都能用贪心算法解决，例如老师在课堂上举的$21$面值纸币的例子，由于存在特殊的比例关系，贪心算法会失效，这时候就需要使用所谓的**动态规划**方法解决，这也是动态规划**动态**的来历，其转移过程中的策略依赖之前的步骤，是不确定的，而非贪心策略确定的局部最优（这一算法本课程不作要求，但有一些同学在解决H12-古堡探险时使用到了动态规划的思想，已在上机课上说明）
    </Tabs.Tab>
</Tabs>


### 滚石问题

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
现在有一个数组 `stone` 表示一系列在同一平面的滚石。`stone` 中的元素绝对值表示滚石的大小，元素的正负表示滚石滚动的方向，正向右，负向左，且大小不同的滚石滚动的速度相同。
现在滚石在同一时间滚动，滚石相撞，较小的石头被摧毁，如果大小相同则都会被摧毁，两颗滚石方向相同则永远不会相撞。请你输出碰撞后还剩下的滚石。

**请用递归算法解决此问题**


#### 输入输出格式
**输入格式**
第一行有一个整数 `stoneSize`，表示数组 `stone` 的大小；
第二行有 `stoneSize` 个整数，表示数组 `stone` 的所有元素，每个整数用一个空格隔开。
**输出格式**
输出还剩下的滚石。
#### 输入输出样例1
**输入**
`3`
`5 10 -5`
**输出**
`5 10`
#### 输入输出样例2
**输入**
`2`
`-10 10`
**输出**
`-10 10`
#### 说明提示
$2 \le stoneSize \le 10^{4}$

$-10^{4} \le stone[i] \le 10^{4}$

$stone[i] != 0$

    </Tabs.Tab>
    <Tabs.Tab>
        递归的思想，每次遍历数组，如果相邻两个元素满足碰撞条件，就删除掉，此时剩下的石头会继续滚动，构成了一个新的滚石问题，所以可以递归调用求解。如果找了一圈没有找到相邻的可以碰撞的石头，说明已经到达了递归的终止条件，直接返回。

        答案：

        ```python copy
        n = int(input())
        stone = [int(x) for x in input().split()]

        def solve(stone):
            for i in range(len(stone)-1):
                if stone[i]> 0 and stone[i+1]<0:
                    if stone[i] > abs(stone[i+1]):
                        stone.pop(i+1)
                    elif stone[i] < abs(stone[i+1]):
                        stone.pop(i)
                    else:
                        stone.pop(i)
                        stone.pop(i)
                    return solve(stone)
            return stone

        print(*solve(stone))
        ```

        在上面的代码中，使用了刚刚学习的解包方法`*`将`[1,2,3]`这样的列表输出为`1 2 3`（空格分隔），较为简便。
        
        之前提供的答案实际上就是迭代方法：

        ```python copy
        n = int(input())
        stone = [int(x) for x in input().split()]

        while True:
            for i in range(len(stone)-1):
                if stone[i]> 0 and stone[i+1]<0:
                    if stone[i] > abs(stone[i+1]):
                        stone.pop(i+1)
                    elif stone[i] < abs(stone[i+1]):
                        stone.pop(i)
                    else:
                        stone.pop(i)
                        stone.pop(i)
                    break
            else:
                break

        print(' '.join(map(str, stone)))
        ```

        **理解**：如果找到了符合条件的相邻石头，就删除掉，然后构成一个新的滚石问题，这里执行`for`循环的`break`后`else`中的语句被跳过，从而重新开始新的`while`循环，进行新一轮的碰撞过程。如果没有找到相邻的可以碰撞的石头，`for`循环正常结束（没有被`break`打断），`else`块中的语句就会被执行，外层`while`循环被下面的`break`打断，输出结果。

        从以上分析中我们可以看出迭代算法和递归算法的区别，二者都适用于可以不断拆分成子问题的情形，递归是函数式编程，往往代码比较简洁，但需要注意递归深度，以及递归的终止条件，当终止后需要向上一层一层传递结果。而迭代是循环式编程，代码比较繁琐，需要显式指定终止条件，自下而上寻找答案，但运行开销更小。

    </Tabs.Tab>
</Tabs>

### 令人头疼的文献

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
公元 `2245` 年，一位年轻的考古学家小昆，意外的发现了一处藏于地下的文献档案室。档案室里收录了从 `1960` 年 `1` 月 `1` 日至 `2059` 年 `12` 月 `31` 日的历史文献，这让小昆欣喜若狂。可当小昆准备整理这些文献时，他遇到了麻烦。这些历史文献中出现了很多日期，可是这些日期采用的格式非常不统一，有采用 `年/月/日` 的，有采用 `月/日/年` 的，还有采用 `日/月/年` 的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  
比如 `02/03/04`，可能是 `2002` 年 `03` 月 `04` 日、`2004` 年 `02` 月 `03` 日或 `2004` 年 `03` 月 `02` 日。  
给出一个文献上的日期，你能帮助小昆判断有哪些可能的日期对其对应吗？
#### 输入输出格式
**输入格式**
输入一个日期，格式是"`AA/BB/CC`"。

**输出格式**
输出若干个不相同的日期，每个日期一行，格式是"`yyyy-MM-dd`"。多个日期按从早到晚排列。  
#### 输入输出样例1
**输入**

```text copy
02/03/04
```
**输出**

```text copy
2002-03-04 
2004-02-03 
2004-03-02
```
#### 输入输出样例2
**输入**
```text copy
11/09/05
```
**输出**
```text copy
2005-09-11
2005-11-09
2011-09-05
```
#### 说明提示
$$0 \le A,B,C \le 9$$

    </Tabs.Tab>
    <Tabs.Tab>
        这道题个人认为很符合`计算概论C`期末考试的要求，因为不涉及任何算法知识，就是考察基础的程序设计和编写能力，涉及输入输出的处理、条件语句、函数等多方面的知识。

        基本思路：注意到年份只提供了后两位数字，但题目恰好满足当年份$year$满足$0 \le year \le 59$时，应当在$2000 \le year \le 2059$，否则在$1960 \le year \le 1999$之间，所以我们可以根据这个条件，判断真实的年份，然后依据三种不同的模式校验日期是否合法，如果合法则加入到结果集中，最后从小到大排序输出。

        参考代码：

        ```python copy
        a,b,c = map(int, input().split('/'))

        # 检验日期是否合法，实际上世纪年只包含2000,并不需要完整的闰年判断
        def validate(year,month,day):
            if month < 1 or month > 12:
                return False
            if day < 1 or day > 31:
                return False
            if month == 2:
                if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
                    if day > 29:
                        return False
                elif day > 28:
                        return False
            if month in [4,6,9,11] and day > 30:
                return False
            return True

        results = []

        # 年/月/日
        if a < 60 and validate(2000+a,b,c):
            results.append(f"20{a:02d}-{b:02d}-{c:02d}")
        if a >= 60 and validate(1900+a,b,c):
            results.append(f"19{a:02d}-{b:02d}-{c:02d}")
        # 月/日/年 和 日/月/年
        if c < 60:
            if validate(2000+c,a,b):
                results.append(f"20{c:02d}-{a:02d}-{b:02d}")
            if validate(2000+c,b,a):
                results.append(f"20{c:02d}-{b:02d}-{a:02d}")
        if c >= 60:
            if validate(1900+c,a,b):
                results.append(f"19{c:02d}-{a:02d}-{b:02d}")
            if validate(1900+c,b,a):
                results.append(f"19{c:02d}-{b:02d}-{a:02d}")

        # 从小到大排序输出
        results.sort()
        for result in results:
            print(result)
        ```

        注意输入的处理，以及如何利用`f-string`构造格式化的日期字符串。如果反应不上来`f-string`的方法，也可以先转换为字符串，然后用条件语句判断是否需要补充前导`0`，最后拼接字符串输出。
    </Tabs.Tab>
</Tabs>

### 青蛙跳台阶

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

### 题目描述
一只青蛙要跳上 `n` 层高的台阶，一次能跳一级，也可以跳两级，请问这只青蛙有多少种跳上这个 `n` 层台阶的方法？
注意：因为测试集输入数很大，这里测评限制 3 秒，递归效率低请勿使用。

**本题为H12最后一题的简化版**

### 输入格式
在一行中，输入 `n` 层（正整数）。

### 输出格式
根据 `n` 层高的台阶求多少种方法（正整数）。

### 输入样例1
#### 输入 
```
9
```
#### 输出 
```
55
```

### 输入样例2
#### 输入 
```
10
```
#### 输出 
```
89
```

    </Tabs.Tab>
    <Tabs.Tab>
        本题是一个典型的类似斐波那契数列的问题，可以用递归解决，使用递归的缓存装饰器`functools.lru_cache`来提高效率。核心思想：青蛙跳到第`n`层台阶的方法数等于跳到第`n-1`层台阶的方法数加上跳到第`n-2`层台阶的方法数，因为青蛙只有可能从第`n-1`层或者`n-2`层跳上来。

        递归解法：

        ```python copy
        from functools import lru_cache

        @lru_cache(None)
        def jump(n):
            if n == 0 or n == 1:
                return 1
            return jump(n - 1) + jump(n - 2)

        n = int(input())
        print(jump(n))
        ```

        **动态规划**解法（不作要求，只是考虑到有些同学在做H12古堡探险时使用了这一方法，简单介绍一下），前面提到动态规划是一种转移策略相比贪心较为复杂的优化方法，它的核心思想也是将问题分解成子问题，然后通过子问题自下而上进行状态转移，最终得到答案。这里我们可以用一个数组`dp`来存储每一层台阶的跳法，然后通过迭代的方式逐步转移状态，最终得到答案，由于每一层台阶的跳法只和前两层有关，所以可以知道这种转移方法是合理的。

        ```python copy
        n = int(input())

        dp = [0] * (n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        print(dp[n])
        ```

        对比发现递归法不使用缓存的情况下，会导致题目超时，这说明了递归法的效率问题，原因是例如我们在计算`jump(5)`的时候会用到`jump(4)`和`jump(3)`，而`jump(4)`又会用到`jump(3)`和`jump(2)`，其中`jump(3)`被重复计算了两次，这种重复计算会导致递归效率低下，而动态规划则是自底向上的计算，可以理解为自带缓存优化的迭代，不会重复计算，所以效率更高。而递归法使用缓存后用时和动态规划相当，建议在递归法超时后使用缓存优化。
    </Tabs.Tab>
</Tabs>

### 量子芯片

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
司博士正在研究一种量子芯片，其逻辑密集度、容量都远远高于普通的半导体芯片。
博士在芯片中设计了 $n$ 个微型光源，每个光源操作一次就会改变其状态，即：点亮转为关闭，或关闭转为点亮。
这些光源的编号从 `1` 到 $n$，开始的时候所有光源都是关闭的。
博士计划在芯片上执行如下动作：

所有编号为 `2` 的倍数的光源操作一次，也就是把 `2 4 6 8 ...` 等序号光源打开

所有编号为 `3` 的倍数的光源操作一次, 也就是对 `3 6 9 ...` 等序号光源操作，注意此时 `6` 号光源又关闭了。

所有编号为 `4` 的倍数的光源操作一次。

.....

直到编号为 $n$ 的倍数的光源操作一次。

司博士想知道：经过这些操作后，某个区间中的哪些光源是点亮的。
#### 输入输出格式
**输入格式**
输入三个用空格分开的整数：`N L R`，`N` 表示光源数，`L` 表示区间的左边界，`R` 表示区间的右边界。

**输出格式**
输出一个整数，表示经过所有操作后，`[L,R]` 区间中有多少个光源是点亮的。
#### 输入输出样例1
**输入**

`5 2 3`

**输出**

`2`
#### 输入输出样例2

**输入**

`6 1 5`

**输出**

`3`
#### 说明提示
$L < R < N < 10^{15}$

    </Tabs.Tab>
    <Tabs.Tab>
        先考虑经典的拉灯问题：

        有100盏灯，编号为1到100，初始状态全是关闭的，现在进行如下操作：
        
        ```text
        第一次，将编号为1的倍数的灯打开
        第二次，将编号为2的倍数的灯开关操作一次
        第三次，将编号为3的倍数的灯开关操作一次
        第四次，将编号为4的倍数的灯开关操作一次
        ......
        第100次，将编号为100的灯开关操作一次
        ```

        问最后有哪些灯是打开的？

        简单观察后发现，一个灯的开关被按动的次数，与其包含的因数个数有关，例如：

        ```text
        1 -> 1 只被按动一次，最后是打开的
        2 -> 1,2 被按动两次，最后是关闭的
        3 -> 1,3 被按动两次，最后是关闭的
        4 -> 1,2,4 被按动三次，最后是打开的
        5 -> 1,5 被按动两次，最后是关闭的
        6 -> 1,2,3,6 被按动四次，最后是关闭的
        7 -> 1,7 被按动两次，最后是关闭的
        8 -> 1,2,4,8 被按动四次，最后是关闭的
        9 -> 1,3,9 被按动三次，最后是打开的
        ...
        ```

        不难发现，一个数的因数个数是奇数时，最后是打开的，否则是关闭的，而一个数的因数个数是奇数时，它一定是一个完全平方数，所以最后剩下的灯是编号为`1,4,9,16,25,36,49,64,81,100`的灯，即完全平方数。

        本题在拉灯问题的基础上作了如下改动：

        1. 取消编号为1的灯的操作，即从2开始操作，可以认为结果刚好相反，即完全平方数是关闭的，非完全平方数是打开的。
        2. 区间问题，需要找到区间内的完全平方数个数
        3. 极大的测试数据（注意本题在头歌上的原始题目是为C或C++程序设计的，存在超出`int`范围的问题，测试数据有误，大家自己刷题的时候需注意，上机课测试的数据已经经过订正），例如最后一个输入数据为：

        ```text copy
        850000000000000 670000099600000 840000099600000
        ```

        **参考答案** （这里直接用两侧取平方根的方法快速计算区间内的完全平方数数量，否则会超时，最后一项是左边界的特殊判断，当左边界也是完全平方数时，需要给完全平方数数目+1）：

        ```python copy
        n,l,r = map(int, input().split())
        print((r-l+1) - (int(r**0.5) - int(l**0.5) + ((l**0.5) % 1 == 0)))
        ```

        **本题目成功难住了`gpt-4o`和`gemini-1.5-pro`，`o1-preview`设法给出了正确答案，但较复杂，粘贴在下面：**

        ```python copy
        def isqrt(n):
            if n == 0 or n == 1:
                return n
            x = n // 2
            y = (x + n // x) // 2
            while y < x:
                x = y
                y = (x + n // x) // 2
            return x if x*x <= n else x-1

        def count_non_perfect_squares(L, R):
            sqrt_R = isqrt(R)
            sqrt_L = isqrt(L - 1) if L > 1 else 0
            perfect_squares = sqrt_R - sqrt_L
            total_numbers = R - L + 1
            return total_numbers - perfect_squares

        def main():
            N_str, L_str, R_str = input().split()
            N = int(N_str)
            L = int(L_str)
            R = int(R_str)
            result = count_non_perfect_squares(L, R)
            print(result)

        if __name__ == "__main__":
            main()
        ```

    </Tabs.Tab>
</Tabs>

### 本源串

<Tabs items={['题目描述','参考答案']}>
    <Tabs.Tab>

#### 题目描述
小明正在参加程序设计大赛，现在他遇到了这样一道题：
由 `0` 和 `1` 组成的串中，不能表示为由几个相同的较小的串连接成的串，称为本原串。有多少个长为 `n` 的本原串？
例如，`100100` 不是本原串，因为他是由两个 `100` 组成，而 `1101` 是本原串。
#### 输入输出格式
**输入格式**

第一行有一个整数 `n`，表示串的长度。
**输出格式**

针对输入，打印出符合要求的本原串数量，答案`mod2008`。
#### 输入输出样例1
**输入**

`2`
**输出**

`2`
#### 输入输出样例2
**输入**

`3`
**输出**

`6`
#### 说明提示
$1 \le n \le 10^8$

    </Tabs.Tab>
    <Tabs.Tab>
        本题是一道递归题目，但思维难度很大。先给出参考答案：

        ```python copy
        n = int(input())

        def get(x):
            if x == 1:
                return 2
            sum = 0 # 除 00...00 和 11...11 外非本源串的数量
            # 非本源串必然具有重复的结构，最小重复单元为本源串（否则会被更小结构的非本源串包含，比如i=4 1010 在 i=2 的时候就被考虑掉了）
            for i in range(1, x):
                if x % i == 0:
                    sum += get(i)
            # 返回本源串的数量
            return (2**x - sum) % 2008

        print(get(n))
        ```

        大致思想如下：

        1. 求本源串不容易，可以反过来求非本源串的数量，本源串的数量就是总串数（因为是二进制串，所以总共有`2**n`种可能）减去非本源串的数量。
        
        2. 非本源串必定具有一个循环节，这个循环节的长度是非本源串长度的因数，例如`100100`长度为6，具有长度为3的循环节`100`，所以我们可以通过枚举循环节的长度来求解。

        3. 为了方便计算，只考虑**最小循环节**，我们发现最小循环节必定是本源串，否则会被更小的本源串包含，例如`10101010`长度为8，具有长度为4的循环节`1010`，但`1010`本身不是本源串，还可以继续分解为`10`，当我们只考虑最小循环节的时候，就能避免重复计算。

        经过上面一通操作，我们发现求解长度`n`的本源串数量转化成——求解长度为`i`的本源串数量，其中`i`是`n`的因数，然后用这个本源串作为最小循环节构造长度为`n`的非本源串，再用总共的串数减去非本源串数量，就得到了答案。这就是递归的思想，将求本源串数量转化为求更小长度的本源串数量，所以我们可以通过递归的方式来求解。

        助教在做这道题的时候猜到了要用递归，但没能把握本质，最后写出了比较丑陋的代码（虽然也过了），供参考（其中`1<<x`表示位运算快速计算`2**x`）：

        ```python copy
        n = int(input())

        def is_prime(x):
            if x < 2:
                return False
            for i in range(2, int(x**0.5)+1):
                if x%i == 0:
                    return False
            return True

        def get(x):
            if is_prime(x):
                return (1<<x) - 2
            return sum([get(i) for i in range(2, x) if x%i == 0]) - 2

        if n == 1:
            print(2)
        else:
            print(((1<<n) - sum([get(i) for i in range(2, n) if n%i == 0]) - 2) % 2008)
        ```
    </Tabs.Tab>
</Tabs>